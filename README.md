# Discord Object Store

üì¶ Turn Discord into secure, distributed file storage with compression, encryption, and chunked uploads.  
üß† Built for both everyday users and developers who want a reliable, scriptable workflow.

## ‚ú® What It Is

Discord Object Store lets you archive files and folders as encrypted, chunked batches stored inside a Discord server. A local SQLite database tracks metadata and enables fast search, downloads, and integrity checks.

## ‚úÖ Use Cases

- üóÇÔ∏è Archive project folders and assets safely in Discord
- üß™ Store large datasets without relying on local disk
- ü§ù Share encrypted batches within a team Discord server
- üß∞ Keep a searchable, versioned backup workflow

## üöÄ Features

- üîí AES-256 (Fernet) encryption with PBKDF2-derived keys
- üóúÔ∏è `.tar.gz` packaging before encryption for better compression
- üì¶ Automatic chunking at 9.5MB to fit Discord limits
- üßµ Threaded storage channel for chunk files
- üóÉÔ∏è Batch index cards for quick lookups
- üß† SQLite metadata store with WAL mode and indexes
- üîÑ Resume interrupted uploads and verify integrity
- üíæ Optional Discord-hosted database backups
- üßë‚Äçüíª Friendly CLI with progress indicators

## üß© Architecture

- **Storage channel** (`STORAGE_CHANNEL_NAME`): threads containing chunk files
- **Batch index channel** (`BATCH_INDEX_CHANNEL_NAME`): human-readable batch cards
- **Archive channel** (`ARCHIVE_CHANNEL_NAME`): reserved for future use
- **Backup channel** (`BACKUP_CHANNEL_NAME`): optional DB backups stored in Discord
- **SQLite**: local metadata store for batches, chunks, files
- **Fernet + PBKDF2**: encryption with per-batch salts

### üìÅ Project Structure

```text
.
‚îú‚îÄ‚îÄ bot.py              # Main CLI entrypoint
‚îú‚îÄ‚îÄ setup.py            # Interactive setup wizard
‚îú‚îÄ‚îÄ requirements.txt    # Python dependencies
‚îú‚îÄ‚îÄ README.md           # Documentation
‚îú‚îÄ‚îÄ .env                # Local config (generated by setup)
‚îú‚îÄ‚îÄ data/               # Local metadata + temp files (created at runtime)
‚îú‚îÄ‚îÄ uploads/            # Staged chunks (optional)
‚îî‚îÄ‚îÄ downloads/          # Restored batches
```

## üõ†Ô∏è Installation

```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

## ‚öôÔ∏è Setup

1. Create a Discord bot in the Developer Portal and invite it to your server.
2. Run the setup wizard:
```bash
python setup.py
```
3. Follow prompts to save your token, generate keys, and optionally sync.

> Note: This version has no Discord chat commands. Everything runs via CLI.

## üîß Configuration

Configuration is created and managed by the setup wizard, but advanced users can edit values directly.

Common settings:
- `STORAGE_CHANNEL_NAME`: channel where chunk threads are created
- `BATCH_INDEX_CHANNEL_NAME`: channel where batch cards are posted
- `BACKUP_CHANNEL_NAME`: optional DB backup channel
- `MAX_CHUNK_SIZE`: chunk size (default 9.5MB)
- `DB_PATH`: local SQLite database path

## üß™ CLI Commands

```bash
python bot.py upload <path>              # Upload file/folder
python bot.py download <batch_id> <path> # Download batch
python bot.py list                       # List batches
python bot.py info <batch_id>            # Batch details
python bot.py delete <batch_id>          # Delete batch (local + optional Discord)
python bot.py stats                      # Storage statistics
python bot.py verify <batch_id>          # Verify integrity
python bot.py resume <batch_id>          # Resume upload
python bot.py backup                     # Backup DB (optional upload to Discord)
python bot.py sync --reset               # Rebuild DB from Discord
```

## üñ•Ô∏è Web UI

Launch a lightweight local dashboard to inspect batches and storage stats:

```bash
python web_app.py --port 8080
```

Then open <http://localhost:8080> to view the dashboard. The UI reads from the same local SQLite database used by the CLI.

## üîÅ Workflow

### ‚¨ÜÔ∏è Upload (Create a Batch)
**Goal:** Turn a folder into a secure, searchable batch stored in Discord.

1. **Scan & summarize**: count files, total size, and build a manifest.
2. **Describe**: add optional title, tags, and description.
3. **Package**: build a `.tar.gz` archive for compact storage.
4. **Encrypt & split**: derive keys (PBKDF2), encrypt with Fernet, split into 9.5MB chunks.
5. **Store**: create a batch card + storage thread, upload chunks concurrently.
6. **Index**: write metadata and hashes to SQLite for fast lookups.

### ‚¨áÔ∏è Download (Restore a Batch)
**Goal:** Reconstruct files exactly as they were uploaded.

1. **Lookup**: read batch metadata from SQLite.
2. **Fetch**: download chunks in parallel from the storage thread.
3. **Verify**: SHA-256 hashes ensure integrity before decrypting.
4. **Assemble**: merge chunks, decrypt the archive, and extract files.

### üîÑ Sync (Rebuild Local State)
**Goal:** Recover metadata if your local DB is missing or stale.

1. **Discover**: read batch cards from the batch index channel.
2. **Resolve**: follow each thread to enumerate chunk attachments.
3. **Rebuild**: recreate the SQLite database with batch/chunk metadata.

## üîê Security Notes

- Never share your bot token or encryption key
- Encryption uses AES-256 (Fernet) with HMAC integrity
- SHA-256 is used to verify chunk integrity
- `.env` and database files are ignored by Git

## üß≠ Developer Notes

- Configuration values live in the setup wizard and environment config
- The local DB is the source of truth for metadata
- Chunk hashes allow integrity verification and resume support

## üß∞ Troubleshooting

- **Invalid token**: Ensure the bot token is correct and has not been regenerated.
- **No guilds found**: Invite the bot to a server and grant permissions.
- **Permission errors**: Ensure the bot can manage threads and send files.
- **Batch not found**: Run `python bot.py sync --reset` to rebuild DB.
- **Large files**: Ensure `MAX_CHUNK_SIZE` is below Discord upload limits.

## ü§ù Contributing

Contributions are welcome! Please open an issue or PR with a clear description of the change and why it helps.

Suggested flow:
1. Fork the repo and create a feature branch
2. Keep changes focused and well-documented
3. Add or update tests if behavior changes
4. Open a PR and link any related issues

## üÜò Support

- Open a GitHub issue for bugs or feature requests
- Include logs, steps to reproduce, and your environment
